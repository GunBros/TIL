- 빅오: 점근적 실행 시간( = 시간 복잡도)를 표기할 때 가장 널리 쓰이는 수학적 표기법
  - 입력값 n이 무한대를 향할 때 함수의 실행시간 추이를 의미
  - 최고차항만을 표기, 상수항은 무시
    - ex) 4n^2 + 3n + 4 ⇒ O(n^2)

<br>

- 빅오 표기법의 종류

  - **O(1)** : 입력값이 아무리 커도 실행시간은 일정하다. 최고의 알고리즘
  - **O(log n)** : 여기서부터 실행 시간은 입력값에 영향을 받게 된다. 그러나 로그는 입력값에도 크게 영향을 받지 않는다. 대표적으로 이진 검색이 이에 해당한다.
  - **O(n)** : 선형 시간 알고리즘. 대표적으로 정렬되지 않은 리스트에서 최대값 또는 최소값을 찾을 때 적어도 한번은 살펴봐야한다
  - **O(nlogn)** : 병합 정렬을 비롯한 대부분의 효울 좋은 알고리즘이 이에 해당. 적어도 모든 수에 대해 한 번 이상 배교해야한다. 아무리 좋은 정렬 알고리즘도 O(nlog)보다는 좋을 수 없다.
  - **O(n^2)** : 버블 정렬과 같은 비효율적인 알고리즘이 이에 해당
  - **O(2^n)** : 피보나치 수를 재귀적 계산 할 때의 복잡도. 이 때부터는 정말 비효율적이라서 알고리즘 테스트에서는 이런 알고리즘은 사용이 불가능하다
  - **O(n!)** : 외판원 문제(TSP: Traveling Saleman Problem)의 시간 복잡도. 가장 느린 알고리즘 복잡도이다.

    <br>

- 대부분의 경우 시간과 공간은 트레이드 오프관계이다

  - 실행 시간이 빠르면 차지하는 공간을 많이 차지한다.
  - 공간을 적게 차지하는 알고리즘은 실행 시간이 오래걸린다.

  <br>

  ## 상한과 최악

  - 상한과 최악을 혼동하지 말자.
    - 빅오 표기법은 정확하기 쓰기에는 너무 길고 복잡한 함수를 적당히 정확하게 표현하는 방법일 뿐 최악/평균적인 경우의 시간 복잡도와는 아무 관련이 없다!
    - ex) 퀵 정렬의 최선의 경우 O(nlogn)이다'라는 아무리 실행 시간이 오래 걸려도 O(nlogn)보다는 느리지 않다는 말이다.
      - 따라서 의미는 없지만 O(n^2), O(n^3)이라고 해도 틀린 것은 아니다.
    - 빅오 표기법은 주어진(최선/최악/평균)경우의 수행 시간의 상한을 나타낸다!

<br>

## 분할 상환 분석

- 시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로 분할 상환 분석 방법이 등장하는 계기가 됐다!

- 대표적인 예: 동적 배열

  - 동적 배열에서 더블링이 일어나는 일은 어쩌다 한번인데 이로 인해 '아이템 삽입 복잡도는 O(n)이다'라고 말하는 것은 지나치게 비관적이고 정확하지 않다.
  - 이 경우 '분할 상환' 또는 '상각'이라고 표현하는 최악의 경우를 여러 번에 나누어서 처리하는 시간 복잡도로 계산하면 O(1)이 된다.

  <br>

## 병렬화

- 일부 알고리즘은 병렬화로 실행 속도를 높일 수 있다.
- 병렬 연산의 대표적인 예: GPU
  - CPU: 비행기, 속도는 빠르지만 나를 수 있는 짐의 무게는 적다.
  - GPU: 선박, 속도는 느리지만 나를 수 있는 짐의 무게는 많다.
- 딥러닝 알고리즘을 비롯해 병렬 연산이 가능한 알고리즘이 주목받는다.
- 알고리즘 자체의 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지는 근래에 알고리즘의 평가하는데 중요한 척도이다.
