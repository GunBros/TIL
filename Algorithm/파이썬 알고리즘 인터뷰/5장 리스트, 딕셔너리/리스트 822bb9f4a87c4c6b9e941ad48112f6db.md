# 리스트

- 리스트: 순서대로저장하는 시퀀스, 변경 가능한 목록
  - 다양한 기능을 제공한다. 스택을 사용할지 큐를 사용할지 고민하지 않아도 된다.

[리스트의 주요 연산 시간 복잡도]

|      연산      | 시간 복잡도 | 설명                                                                                                                                                                                      |
| :------------: | :---------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     len(a)     |    O(1)     | 전체 요소의 개수를 리턴한다.                                                                                                                                                              |
|      a[i]      |    O(1)     | 인덱스 i의 요소를 가져온다.                                                                                                                                                               |
|    a[i : j]    |    O(k)     | i부터 j까지 슬라이스의 길이만큼 k개의 요소를 가져온다. 이 경우 객체 k개에 대한 조회가 필요하므로 O(K)이다.                                                                                |
|   elem in a    |    O(n)     | elem요소가 존재하는지 확인한다. 처음부터 순차 탐색하므로 n만큼 시간이 소요된다..                                                                                                          |
| a.count(elem)  |    O(n)     | elem요소의 개수를 리턴한다.                                                                                                                                                               |
| a.index(elem)  |    O(n)     | elem요소의 인덱스를 리턴한다.                                                                                                                                                             |
| a.append(elem) |    O(1)     | 리스트 마지막 요소를 추출한다. 스택의 연산                                                                                                                                                |
|    a.pop()     |    O(1)     | 전체 요소의 개수를 리턴한다.                                                                                                                                                              |
|    a.pop(0)    |    O(n)     | 리스트 첫번째 요소를 추출한다. 큐의 연산이다. 이 경우 전체 복사가 필요하므로 O(n)이다. 나중에 다시 살펴보겠지만 큐의 연산을 주로 사용한다면 리스트보다는 O(1)에 가능한 데크(deque)를 권장 |
|    del a[i]    |    O(n)     | i에 따라 다르다. 최악의 경우 O(n)이다.                                                                                                                                                    |
|    a.sort()    | O(n log n)  | 정렬한다. 팀소트(Timsort)를 사용하며 최선의 경우 O(n)에도 실행될 수 있다. 6장에서 설명                                                                                                    |
| min(a), max(a) |    O(n)     | 최솟값/최댓값을 계산하기 위해서는 전체를 선형탐색해야한다.                                                                                                                                |
|  a.reverse()   |    O(n)     | 뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다.                                                                                                            |

## 리스트의 활용 방법

- 리스트를 선언하는 방법

```python
a = list()

a = []
```

- 초기값을 지정하고 append()로 추가

```python
a = [1,2,3]
print(a)
# [1, 2, 3]

a.append(4)
print(a)
# [1, 2, 3, 4]
```

- insert()를 통해 원하는 인덱스에 요소를 추가 할 수 있다.

```python
a.insert(3, 5)
print(a)
# [1, 2, 3, 5, 4]
```

- 리스트에는 다양한 타입을 집어넣을 수 있다. 동일한 자료형만 넣어야하는 다른 언어들에 비해 파이썬은 자유롭게 처리할 수 있다.

```python
a.append('안녕')
a.append(True)
print(a)
# [1, 2, 3, 5, 4, '안녕', True]
```

- 인덱스를 지정해 값을 조회할 수 있다.

```python
print(a[3])
# 5
```

- 리스트 슬라이싱

  - [1:3] ⇒ 1포함 3전까지(3은 포함 X)

  ```python
  print(a[1:3])
  # [2, 3]
  ```

- 시작 인덱스와 종료 인덱스를 따로 지정하지 않아도 된다.

```python
print(a[:3])
# [1, 2, 3]
# 처음부터 2까지

print(a[4:])
# [4, '안녕', True]
# 4부터 마지막까지
```

- 세번째 파라미터로 단계를 부여할 수 있다.

```python
print(a[1:4])
# [2, 3, 5]

print(a[1:4:2])
# [2, 5]
# 1을 시작으로 2씩 증가, (1, 3)
```

- 존재하지 않는 인덱스에 접근할 경우 오류가 발생

```python
print(a[9])
# Traceback (most recent call last):
#   File "C:/Users/My/PycharmProjects/pythonCodingTest/main.py", line 29, in <module>
#     print(a[9])
# IndexError: list index out of range
```

- IndexError를 try 구문으로 에러에 대한 예외 처리를 할 수 있다.

```python
try:
    print(a[9])
except IndexError:
    print('존재하지 않는 인덱스')
```

- 요소를 삭제하는 3가지 방법

  - del a[인덱스]

  ```python
  print(a)
  # [1, 2, 3, 5, 4, '안녕', True]
  del a[1]
  print(a)
  # [1, 3, 5, 4, '안녕', True]
  ```

  - a.remove(element)

  ```python
  print(a)
  # [1, 3, 5, 4, '안녕', True]
  a.remove(3)
  print(a)
  # [1, 5, 4, '안녕', True]
  ```

  - a.pop(인덱스)

  ```python
  print(a)
  # [1, 5, 4, '안녕', True]
  a.pop(3)
  print(a)
  # [1, 5, 4, True]
  ```

## 리스트의 특징

- 파이썬의 리스트는 연속된 공간에 요소를 배치하는 배열의 장점과 다양한 타입을 연결해 배치하는 연결 리스트의 장점을 모두 취한 형태

  - 리스트를 잘 사용해도 배열과 연결 리스트가 모두 필요 없을 정도로 강력
  - 때문에 파이썬은 아예 원시 타입 배열을 제공 하지 않는다.

- CPython에서 리스트는 요소에 대한 포인터 목록(ob_item)을 갖고 있는 구조체로 선언되어 있다.
  - 리스트의 요소를 추가하거나 조작하기 시작하면 ob_item의 사이즈를 조절해 나가는 구조

```c
typedef struct{
	PyObject_VAR_HEAD
	PyObject **ob_item;
	Py_ssize_t allocated;
} PyListObject;
```

- 파이썬의 리스트는 객체에 대한 포인터 목록을 관리하는 형태로 구현되어 있다.

  - 따라서 다양한 타입을 담을 수 있다.
  - 당연히 연속된 메모리에 할당하는 것은 불가능하다.

  ![Untitled](https://user-images.githubusercontent.com/53499412/116637494-0d1f9580-a99f-11eb-954b-e56da9c1ff2f.png)

- 인덱스를 조회해도 포인터를 따라가서 타입 코드를 일일히 살펴봐야하는 등 추가적인 작업이 필요하기 때문에 속도면에서 불리하다.
